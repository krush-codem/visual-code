// src/App.jsx

import React, { useState, useEffect, useCallback } from "react";
import Editor from "@monaco-editor/react";
import {
  ReactFlow,
  useNodesState,
  useEdgesState,
  addEdge,
  Controls,
  Background,
} from "@xyflow/react";
import * as babelParser from "@babel/parser";
import traverse from "@babel/traverse";
import path from "path-browserify";

// --- NEW IMPORTS ---
import { useDebounce } from "./hooks/useDebounce";
import LoadingScreen from "./components/LoadingScreen";
import ReadmeModal from "./components/ReadmeModal";
import {
  processDirectory,
  resolveImportPath,
  buildFileTree,
  generateFeatureBullets,
} from "./utils/utils";

// --- ADD THESE LINES ---
import FileExplorer from './components/FileExplorer';
import CodeEditor from './components/CodeEditor';
import Visualizer from './components/Visualizer';

import {
  ResizableHandle,
  ResizablePanel,
  ResizablePanelGroup,
} from "@/components/ui/resizable";

// --- CSS (Keep this) ---
import "@xyflow/react/dist/style.css";

function App() {
  // --- STATE ---
  const [projectFiles, setProjectFiles] = useState([]);
  const [activeFileContent, setActiveFileContent] = useState(
    '// Click "Open Folder" to start'
  );
  const [showReadme, setShowReadme] = useState(false);
  const [readmeContent, setReadmeContent] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const onConnect = useCallback(
    (params) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  // --- HANDLERS ---
  const handleFolderOpen = async () => {
    try {
      setIsLoading(true);
      const directoryHandle = await window.showDirectoryPicker();
      const allFiles = await processDirectory(directoryHandle); // from utils

      setProjectFiles(allFiles);

      const entryFile = allFiles.find(
        (f) => f.path.endsWith("index.js") || f.path.endsWith("App.js")
      );
      if (entryFile) {
        setActiveFileContent(entryFile.content);
      } else if (allFiles.length > 0) {
        setActiveFileContent(allFiles[0].content);
      }
      setIsLoading(false);
    } catch (err) {
      console.error("Error opening folder (or user cancelled):", err);
      setIsLoading(false);
    }
  };

  const handleFileClick = (file) => {
    setActiveFileContent(file.content);
  };

  const handleGenerateReadme = () => {
    const pkgFile = projectFiles.find((f) => f.path.endsWith("package.json"));
    if (!pkgFile) {
      alert("Could not find package.json in the project.");
      return;
    }
    try {
      const pkg = JSON.parse(pkgFile.content);
      let projectName = pkg.name || "My Project";
      let description =
        pkg.description ||
        "A description of the project. (Update this in your package.json!)";

      let installation = `\`\`\`bash\nnpm install\n\`\`\``;
      const scripts = pkg.scripts
        ? Object.entries(pkg.scripts)
            .map(
              ([name, command]) => `- \`npm run ${name}\`: Runs \`${command}\``
            )
            .join("\n")
        : "*No scripts found.*";
      let usage = `To run this project, use the following scripts:\n\n${scripts}`;
      const deps = pkg.dependencies
        ? Object.keys(pkg.dependencies)
            .map((d) => `- \`${d}\``)
            .join("\n")
        : "*None*";
      let dependencies = `### Dependencies\n${deps}\n\n`;
      const devDeps = pkg.devDependencies
        ? Object.keys(pkg.devDependencies)
            .map((d) => `- \`${d}\``)
            .join("\n")
        : "";
      if (devDeps) {
        dependencies += `### Dev Dependencies\n${devDeps}`;
      }

      const featureBullets = generateFeatureBullets(pkg, projectFiles); // from utils
      const fileTree = buildFileTree(projectFiles); // from utils

      const mdContent = `
# ${projectName}
${description}
## âœ¨ Key Features
${featureBullets}
## ðŸš€ Installation
${installation}
## Usage
${usage}
## ðŸ“‚ Project Structure
\`\`\`
${fileTree}
\`\`\`
## External Dependencies
${dependencies}
## ðŸ¤ Contributing
Contributions are welcome!
## ðŸ“„ License
*This project is not licensed.*
## ðŸ“ž Contact
*your-email@example.com*
---
*This README was auto-generated by CodeFlow IDE.*
`;

      setReadmeContent(mdContent);
      setShowReadme(true);
    } catch (err) {
      alert("Failed to parse package.json: " + err.message);
    }
  };

  // --- EFFECTS ---
  useEffect(() => {
    if (projectFiles.length === 0) {
      setNodes([]);
      setEdges([]);
      return;
    }
    const allFilePaths = projectFiles.map((f) => f.path);
    const newNodes = [];
    const newEdges = [];
    projectFiles.forEach((file, i) => {
      newNodes.push({
        id: file.path,
        data: { label: path.basename(file.path) },
        position: { x: (i % 5) * 200, y: Math.floor(i / 5) * 100 },
      });
    });
    projectFiles.forEach((file) => {
      if (!/\.(js|jsx|ts|tsx)$/.test(file.path)) {
        return;
      }
      try {
        const ast = babelParser.parse(file.content, {
          sourceType: "module",
          plugins: ["jsx", "typescript"],
          errorRecovery: true,
        });
        traverse(ast, {
          ImportDeclaration({ node }) {
            const importPath = node.source.value;
            const resolvedPath = resolveImportPath(
              file.path,
              importPath,
              allFilePaths
            ); // from utils
            if (resolvedPath && allFilePaths.includes(resolvedPath)) {
              newEdges.push({
                id: `e-${file.path}-to-${resolvedPath}`,
                source: resolvedPath,
                target: file.path,
                animated: true,
              });
            } else if (resolvedPath) {
              if (!newNodes.find((n) => n.id === resolvedPath)) {
                newNodes.push({
                  id: resolvedPath,
                  data: { label: resolvedPath },
                  position: {
                    x: Math.random() * 500,
                    y: Math.random() * 500 + 400,
                  },
                  style: { background: "#fdd", borderColor: "#f00" },
                });
              }
              newEdges.push({
                id: `e-${file.path}-to-${resolvedPath}`,
                source: resolvedPath,
                target: file.path,
                label: "external",
              });
            }
          },
        });
      } catch (err) {
        console.error(`Could not parse ${file.path}: ${err.message}`);
      }
    });
    setNodes(newNodes);
    setEdges(newEdges);
  }, [projectFiles, setNodes, setEdges]);

  // --- RENDER ---
  return (
    <div className="h-screen w-screen bg-background text-foreground">
      {isLoading && <LoadingScreen />}

      {showReadme && (
        <ReadmeModal
          content={readmeContent}
          onClose={() => setShowReadme(false)}
        />
      )}

      {/* This is the new layout */}
      <ResizablePanelGroup direction="horizontal" className="h-full w-full">
        {/* Panel 1: File Explorer */}
        <ResizablePanel defaultSize={20} minSize={15}>
          <FileExplorer
            projectFiles={projectFiles}
            onFolderOpen={handleFolderOpen}
            onReadmeGen={handleGenerateReadme}
            onFileClick={handleFileClick}
            isDisabled={projectFiles.length === 0}
          />
        </ResizablePanel>

        <ResizableHandle withHandle />

        {/* Panel 2: Code Editor */}
        <ResizablePanel defaultSize={40} minSize={30}>
          <CodeEditor
            content={activeFileContent}
            onContentChange={setActiveFileContent}
          />
        </ResizablePanel>

        <ResizableHandle withHandle />

        {/* Panel 3: Visualizer */}
        <ResizablePanel defaultSize={40} minSize={30}>
          <Visualizer
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
          />
        </ResizablePanel>
      </ResizablePanelGroup>
    </div>
  );
}

export default App;
