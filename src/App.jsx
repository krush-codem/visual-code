import React, { useState, useEffect, useCallback } from "react";
import {
  ReactFlow,
  useNodesState,
  useEdgesState,
  addEdge,
} from "@xyflow/react";
import * as babelParser from "@babel/parser";
import traverse from "@babel/traverse";
import path from "path-browserify";

import LoadingScreen from "./components/LoadingScreen";
import ReadmeModal from "./components/ReadmeModal";

import {
  processDirectory,
  resolveImportPath,
  buildFileTree,
  generateFeatureBullets,
} from "./utils/utils";

// NEW COMPONENTS
import FileExplorer from "./components/FileExplorer";
import CodeEditor from "./components/CodeEditor";
import Visualizer from "./components/Visualizer";
import HistoryPanel from "./components/HistoryPanel";

// NEW HOOK (IndexedDB Auto-Save)
import useAutoSaveIndexed from "./hooks/useAutoSaveIndexed";

// UI RESIZERS
import {
  ResizableHandle,
  ResizablePanel,
  ResizablePanelGroup,
} from "@/components/ui/resizable";

import "@xyflow/react/dist/style.css";

function App() {
  // -------------------------------
  // STATE
  // -------------------------------

  const [projectFiles, setProjectFiles] = useState([]);
  const [activeFileContent, setActiveFileContent] = useState(
    '// Click "Open Folder" to start'
  );

  const [showReadme, setShowReadme] = useState(false);
  const [readmeContent, setReadmeContent] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);

  const [showHistory, setShowHistory] = useState(false);

  const onConnect = useCallback(
    (params) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  // -------------------------------
  // IndexedDB Auto-save Hook
  // -------------------------------

  const {
    saveSnapshot,
    historyEntries,
    restoreSnapshot,
    isReady: historyReady,
  } = useAutoSaveIndexed();

  // Load last session
  useEffect(() => {
    if (!historyReady) return;

    const last = historyEntries[0];
    if (last) setActiveFileContent(last.code);
  }, [historyReady]);

  // Auto-save every time editor changes
  useEffect(() => {
    if (activeFileContent) saveSnapshot(activeFileContent);
  }, [activeFileContent]);

  // -------------------------------
  // OPEN FOLDER
  // -------------------------------

  const handleFolderOpen = async () => {
    try {
      setIsLoading(true);

      const directoryHandle = await window.showDirectoryPicker();
      const allFiles = await processDirectory(directoryHandle);

      setProjectFiles(allFiles);

      const entryFile =
        allFiles.find(
          (f) => f.path.endsWith("index.js") || f.path.endsWith("App.js")
        ) || allFiles[0];

      if (entryFile) setActiveFileContent(entryFile.content);

      setIsLoading(false);
    } catch (err) {
      console.error("Folder open error:", err);
      setIsLoading(false);
    }
  };

  // -------------------------------
  // FILE CLICK
  // -------------------------------

  const handleFileClick = (file) => {
    setActiveFileContent(file.content);
  };

  // -------------------------------
  // README GENERATION
  // -------------------------------

  const handleGenerateReadme = () => {
    const pkgFile = projectFiles.find((f) => f.path.endsWith("package.json"));

    if (!pkgFile) return alert("package.json not found.");

    try {
      const pkg = JSON.parse(pkgFile.content);

      const projectName = pkg.name || "My Project";
      const description = pkg.description || "A description of the project.";

      const installation = `\`\`\`bash
npm install
\`\`\``;

      const scripts = pkg.scripts
        ? Object.entries(pkg.scripts)
            .map(([name, cmd]) => `- \`npm run ${name}\`: Runs \`${cmd}\``)
            .join("\n")
        : "*No scripts found.*";

      const deps = pkg.dependencies
        ? Object.keys(pkg.dependencies)
            .map((d) => `- \`${d}\``)
            .join("\n")
        : "*None*";

      const devDeps = pkg.devDependencies
        ? Object.keys(pkg.devDependencies)
            .map((d) => `- \`${d}\``)
            .join("\n")
        : "";

      const featureBullets = generateFeatureBullets(pkg, projectFiles);
      const fileTree = buildFileTree(projectFiles);

      const md = `
# ${projectName}
${description}

## âœ¨ Key Features
${featureBullets}

## ðŸš€ Installation
${installation}

## ðŸ“‚ Project Structure
\`\`\`
${fileTree}
\`\`\`

## ðŸ“¦ Scripts
${scripts}

## Dependencies
${deps}

${devDeps ? `### Dev Dependencies\n${devDeps}` : ""}

---
*Auto-generated by CodeFlow IDE.*
`;

      setReadmeContent(md);
      setShowReadme(true);
    } catch (err) {
      alert("Failed to parse package.json");
    }
  };

  // -------------------------------
  // AST GRAPH BUILDER
  // -------------------------------

  useEffect(() => {
    if (!projectFiles.length) {
      setNodes([]);
      setEdges([]);
      return;
    }

    const allPaths = projectFiles.map((f) => f.path);

    const n = [];
    const e = [];

    // Build nodes
    projectFiles.forEach((file, i) => {
      n.push({
        id: file.path,
        data: { label: path.basename(file.path) },
        position: {
          x: (i % 5) * 200,
          y: Math.floor(i / 5) * 120,
        },
      });
    });

    // Build edges
    projectFiles.forEach((file) => {
      if (!/\.(js|jsx|ts|tsx)$/.test(file.path)) return;

      try {
        const ast = babelParser.parse(file.content, {
          sourceType: "module",
          plugins: ["jsx", "typescript"],
        });

        traverse(ast, {
          ImportDeclaration({ node }) {
            const importPath = node.source.value;
            const resolved = resolveImportPath(file.path, importPath, allPaths);

            if (resolved && allPaths.includes(resolved)) {
              e.push({
                id: `e-${file.path}-${resolved}`,
                source: resolved,
                target: file.path,
                animated: true,
              });
            }
          },
        });
      } catch (err) {
        console.warn("Parse error:", file.path);
      }
    });

    setNodes(n);
    setEdges(e);
  }, [projectFiles]);

  // -------------------------------
  // RENDER
  // -------------------------------

  return (
    <div className="h-screen w-screen bg-background text-foreground">
      {isLoading && <LoadingScreen />}

      {showReadme && (
        <ReadmeModal
          content={readmeContent}
          onClose={() => setShowReadme(false)}
        />
      )}

      {showHistory && (
        <HistoryPanel
          historyEntries={historyEntries}
          onClose={() => setShowHistory(false)}
          onRestore={(entry) => {
            restoreSnapshot(entry);
            setShowHistory(false);
          }}
        />
      )}

      <ResizablePanelGroup direction="horizontal" className="h-full w-full">
        {/* LEFT PANEL â€” FILES */}
        <ResizablePanel minSize={15} defaultSize={20}>
          <FileExplorer
            projectFiles={projectFiles}
            onFolderOpen={handleFolderOpen}
            onReadmeGen={handleGenerateReadme}
            onFileClick={handleFileClick}
            onOpenHistory={() => setShowHistory(true)}
            isDisabled={projectFiles.length === 0}
          />
        </ResizablePanel>

        <ResizableHandle withHandle />

        {/* MIDDLE â€” EDITOR */}
        <ResizablePanel minSize={30} defaultSize={40}>
          <CodeEditor
            content={activeFileContent}
            onContentChange={setActiveFileContent}
          />
        </ResizablePanel>

        <ResizableHandle withHandle />

        {/* RIGHT â€” VISUALIZER */}
        <ResizablePanel minSize={30} defaultSize={40}>
          <Visualizer
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
          />
        </ResizablePanel>
      </ResizablePanelGroup>
    </div>
  );
}

export default App;
